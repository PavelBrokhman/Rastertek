<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0126)mhtml:file://D:\Projects\DirectX Projects\Rastertek\Original Tutorials\DirectX11Archive\Tutorial 3 Initializing DirectX 11.mht -->
<HTML><HEAD><META content="IE=5.0000" http-equiv="X-UA-Compatible">
<TITLE>Tutorial 3: Initializing DirectX 11</TITLE>
<META content=IE=5.0000 http-equiv=X-UA-Compatible>
<SCRIPT type=text/javascript 
src="Tutorial%203%20Initializing%20DirectX%2011_files/analytics.js"></SCRIPT>

<META content="text/html; charset=utf-8" http-equiv=Content-Type><LINK 
rel=stylesheet type=text/css 
href="Tutorial%203%20Initializing%20DirectX%2011_files/banner-styles.css">
<META name=GENERATOR content="MSHTML 11.00.9600.17344"></HEAD>
<BODY bgColor=#000000 text=#ffffff><!-- BEGIN WAYBACK TOOLBAR INSERT -->
<SCRIPT> if (window.archive_analytics) { window.archive_analytics.values['server_name']="wwwb-app17.us.archive.org";}; </SCRIPT>

<SCRIPT type=text/javascript 
src="Tutorial%203%20Initializing%20DirectX%2011_files/disclaim-element.js"></SCRIPT>

<SCRIPT type=text/javascript 
src="Tutorial%203%20Initializing%20DirectX%2011_files/graph-calc.js"></SCRIPT>

<SCRIPT type=text/javascript 
src="Tutorial%203%20Initializing%20DirectX%2011_files/jquery.min.js"></SCRIPT>

<SCRIPT type=text/javascript>
//<![CDATA[
var firstDate = 820454400000;
var lastDate = 1420070399999;
var wbPrefix = "/web/";
var wbCurrentUrl = "http:\/\/www.rastertek.com\/dx11tut03.html";

var curYear = -1;
var curMonth = -1;
var yearCount = 18;
var firstYear = 1996;
var imgWidth = 475;
var yearImgWidth = 25;
var monthImgWidth = 2;
var trackerVal = "none";
var displayDay = "2";
var displayMonth = "Jul";
var displayYear = "2014";
var prettyMonths = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];

function showTrackers(val) {
	if(val == trackerVal) {
		return;
	}
	if(val == "inline") {
		document.getElementById("displayYearEl").style.color = "#ec008c";
		document.getElementById("displayMonthEl").style.color = "#ec008c";
		document.getElementById("displayDayEl").style.color = "#ec008c";		
	} else {
		document.getElementById("displayYearEl").innerHTML = displayYear;
		document.getElementById("displayYearEl").style.color = "#ff0";
		document.getElementById("displayMonthEl").innerHTML = displayMonth;
		document.getElementById("displayMonthEl").style.color = "#ff0";
		document.getElementById("displayDayEl").innerHTML = displayDay;
		document.getElementById("displayDayEl").style.color = "#ff0";
	}
   document.getElementById("wbMouseTrackYearImg").style.display = val;
   document.getElementById("wbMouseTrackMonthImg").style.display = val;
   trackerVal = val;
}
function getElementX2(obj) {
	var thing = jQuery(obj);
	if((thing == undefined) 
			|| (typeof thing == "undefined") 
			|| (typeof thing.offset == "undefined")) {
		return getElementX(obj);
	}
	return Math.round(thing.offset().left);
}
function trackMouseMove(event,element) {

   var eventX = getEventX(event);
   var elementX = getElementX2(element);
   var xOff = eventX - elementX;
	if(xOff < 0) {
		xOff = 0;
	} else if(xOff > imgWidth) {
		xOff = imgWidth;
	}
   var monthOff = xOff % yearImgWidth;

   var year = Math.floor(xOff / yearImgWidth);
	var yearStart = year * yearImgWidth;
   var monthOfYear = Math.floor(monthOff / monthImgWidth);
   if(monthOfYear > 11) {
       monthOfYear = 11;
   }
   // 1 extra border pixel at the left edge of the year:
   var month = (year * 12) + monthOfYear;
   var day = 1;
	if(monthOff % 2 == 1) {
		day = 15;
	}
	var dateString = 
		zeroPad(year + firstYear) + 
		zeroPad(monthOfYear+1,2) +
		zeroPad(day,2) + "000000";

	var monthString = prettyMonths[monthOfYear];
	document.getElementById("displayYearEl").innerHTML = year + 1996;
	document.getElementById("displayMonthEl").innerHTML = monthString;
	// looks too jarring when it changes..
	//document.getElementById("displayDayEl").innerHTML = zeroPad(day,2);

	var url = wbPrefix + dateString + '/' +  wbCurrentUrl;
	document.getElementById('wm-graph-anchor').href = url;

   //document.getElementById("wmtbURL").value="evX("+eventX+") elX("+elementX+") xO("+xOff+") y("+year+") m("+month+") monthOff("+monthOff+") DS("+dateString+") Moy("+monthOfYear+") ms("+monthString+")";
   if(curYear != year) {
       var yrOff = year * yearImgWidth;
       document.getElementById("wbMouseTrackYearImg").style.left = yrOff + "px";
       curYear = year;
   }
   if(curMonth != month) {
       var mtOff = year + (month * monthImgWidth) + 1;
       document.getElementById("wbMouseTrackMonthImg").style.left = mtOff + "px";
       curMonth = month;
   }
}
//]]>
</SCRIPT>

<STYLE type=text/css>BODY {
	MIN-WIDTH: 800px !important; PADDING-TOP: 0px !important; MARGIN-TOP: 0px !important
}
#wm-ipp A:hover {
	TEXT-DECORATION: underline !important
}
</STYLE>

<DIV lang=en id=wm-ipp class=__wb_banner_div 
style="MIN-WIDTH: 800px; POSITION: relative; PADDING-BOTTOM: 0px; PADDING-TOP: 0px; PADDING-LEFT: 5px; MIN-HEIGHT: 70px; DISPLAY: none; PADDING-RIGHT: 5px">
<DIV id=wm-ipp-inside class=__wb_banner_div 
style='FONT-SIZE: 11px !important; BORDER-TOP: medium none; FONT-FAMILY: "Lucida Grande","Arial",sans-serif !important; BORDER-RIGHT: 5px solid; WIDTH: 97%; BACKGROUND-IMAGE: url(/static/images/toolbar/wm_tb_bk_trns.png); MIN-WIDTH: 780px; BORDER-BOTTOM: 5px solid; POSITION: fixed; PADDING-BOTTOM: 0px !important; TEXT-ALIGN: center; PADDING-TOP: 0px !important; PADDING-LEFT: 0px !important; MARGIN: 0px; BORDER-LEFT: 5px solid; PADDING-RIGHT: 0px !important; border-image: none; box-shadow: 1px 1px 3px #333; -moz-box-shadow: 1px 1px 3px #333; -webkit-box-shadow: 1px 1px 3px #333'>
<TABLE 
style="WIDTH: 100%; BORDER-COLLAPSE: collapse; PADDING-BOTTOM: 0px; PADDING-TOP: 0px; PADDING-LEFT: 0px; MARGIN: 0px; PADDING-RIGHT: 0px">
  <TBODY>
  <TR>
    <TD 
    style="VERTICAL-ALIGN: top; MIN-WIDTH: 110px; PADDING-BOTTOM: 10px; PADDING-TOP: 10px; PADDING-LEFT: 10px; PADDING-RIGHT: 10px"><A 
      title="Wayback Machine home page" 
      style="BACKGROUND-COLOR: transparent; border-image: none" 
      href="http://web.archive.org/web/"><IMG border=0 alt="Wayback Machine" 
      src="Tutorial%203%20Initializing%20DirectX%2011_files/mhtC2D0(1).tmp" 
      width=110 height=39></A> </TD>
    <TD 
    style="WIDTH: 100%; VERTICAL-ALIGN: top; PADDING-BOTTOM: 0px !important; TEXT-ALIGN: center; PADDING-TOP: 0px !important; PADDING-LEFT: 0px !important; PADDING-RIGHT: 0px !important">
      <TABLE 
      style="WIDTH: 570px; BORDER-COLLAPSE: collapse; PADDING-BOTTOM: 0px; PADDING-TOP: 0px; PADDING-LEFT: 0px; MARGIN: 0px auto; PADDING-RIGHT: 0px">
        <TBODY>
        <TR>
          <TD 
          style="PADDING-BOTTOM: 3px; PADDING-TOP: 3px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px" 
          colSpan=2>
            <FORM id=wmtb 
            style="PADDING-BOTTOM: 0px !important; PADDING-TOP: 0px !important; PADDING-LEFT: 0px !important; MARGIN: 0px; PADDING-RIGHT: 0px !important" 
            method=get name=wmtb action=/web/form-submit.jsp target=_top><INPUT 
            onfocus=javascript:this.focus();this.select(); id=wmtbURL 
            style='FONT-SIZE: 11px; FONT-FAMILY: "Lucida Grande","Arial",sans-serif; WIDTH: 400px' 
            value=http://www.rastertek.com/dx11tut03.html name=url><INPUT 
            type=hidden value=replay name=type><INPUT type=hidden 
            value=20140702091336 name=date><INPUT style='FONT-SIZE: 11px; FONT-FAMILY: "Lucida Grande","Arial",sans-serif; MARGIN-LEFT: 5px' type=submit value=Go><SPAN 
            id=wm_tb_options style="DISPLAY: block"></SPAN></FORM></TD>
          <TD 
          style="VERTICAL-ALIGN: bottom; PADDING-BOTTOM: 0px !important; PADDING-TOP: 5px !important; PADDING-LEFT: 0px !important; PADDING-RIGHT: 0px !important" 
          rowSpan=2>
            <TABLE 
            style='FONT-FAMILY: "Helvetica","Lucida Grande","Arial",sans-serif; WIDTH: 110px; BORDER-COLLAPSE: collapse; COLOR: rgb(153,153,170)'>
              <TBODY><!-- NEXT/PREV MONTH NAV AND MONTH INDICATOR -->
              <TR 
style="FONT-SIZE: 10px !important; HEIGHT: 16px; WIDTH: 110px">
                <TD 
                style="OVERFLOW: visible; FONT-SIZE: 11px !important; WHITE-SPACE: nowrap; TEXT-TRANSFORM: uppercase; FONT-WEIGHT: bold; TEXT-ALIGN: right; PADDING-RIGHT: 9px" 
                noWrap><A title="24 Mar 2014" 
                  style="TEXT-DECORATION: none; FONT-WEIGHT: bold; COLOR: rgb(51,51,255); BACKGROUND-COLOR: transparent; border-image: none" 
                  href="http://web.archive.org/web/20140324185816/http://www.rastertek.com/dx11tut03.html"><STRONG>MAR</STRONG></A> 
                </TD>
                <TD id=displayMonthEl title="You are here: 9:13:36 Jul 2, 2014" 
                style="FONT-SIZE: 11px !important; HEIGHT: 15px; WIDTH: 34px; BACKGROUND: rgb(0,0,0); TEXT-TRANSFORM: uppercase; FONT-WEIGHT: bold; COLOR: rgb(255,255,0); TEXT-ALIGN: center; PADDING-TOP: 1px">JUL</TD>
                <TD 
                style="OVERFLOW: visible; FONT-SIZE: 11px !important; WHITE-SPACE: nowrap; TEXT-TRANSFORM: uppercase; FONT-WEIGHT: bold; PADDING-LEFT: 9px" 
                noWrap>Aug </TD></TR><!-- NEXT/PREV CAPTURE NAV AND DAY OF MONTH INDICATOR -->
              <TR>
                <TD 
                style="OVERFLOW: visible; VERTICAL-ALIGN: middle !important; WHITE-SPACE: nowrap; TEXT-ALIGN: right !important; PADDING-RIGHT: 9px" 
                noWrap><A title="18:58:16 Mar 24, 2014" 
                  style="BACKGROUND-COLOR: transparent; border-image: none" 
                  href="http://web.archive.org/web/20140324185816/http://www.rastertek.com/dx11tut03.html"><IMG 
                  border=0 alt="Previous capture" 
                  src="Tutorial%203%20Initializing%20DirectX%2011_files/mhtC2D3(1).tmp" 
                  width=14 height=16></A> </TD>
                <TD id=displayDayEl title="You are here: 9:13:36 Jul 2, 2014" 
                style="FONT-SIZE: 24px; HEIGHT: 24px; WIDTH: 34px; BACKGROUND: rgb(0,0,0); FONT-WEIGHT: bold; COLOR: rgb(255,255,0); PADDING-BOTTOM: 0px; TEXT-ALIGN: center; PADDING-TOP: 2px; PADDING-LEFT: 0px; PADDING-RIGHT: 0px">2</TD>
                <TD 
                style="OVERFLOW: visible; VERTICAL-ALIGN: middle !important; WHITE-SPACE: nowrap; TEXT-ALIGN: left !important; PADDING-LEFT: 9px" 
                noWrap><A title="7:50:00 Jul 22, 2014" 
                  style="BACKGROUND-COLOR: transparent; border-image: none" 
                  href="http://web.archive.org/web/20140722075000/http://rastertek.com/dx11tut03.html"><IMG 
                  border=0 alt="Next capture" 
                  src="Tutorial%203%20Initializing%20DirectX%2011_files/mhtC2E5(1).tmp" 
                  width=14 height=16></A> </TD></TR><!-- NEXT/PREV YEAR NAV AND YEAR INDICATOR -->
              <TR 
                style="FONT-SIZE: 9px !important; HEIGHT: 13px; WIDTH: 110px"><TD 
                style="OVERFLOW: visible; FONT-SIZE: 11px !important; WHITE-SPACE: nowrap; FONT-WEIGHT: bold; TEXT-ALIGN: right; PADDING-RIGHT: 9px" 
                noWrap><A title="26 May 2013" 
                  style="TEXT-DECORATION: none; FONT-WEIGHT: bold; COLOR: rgb(51,51,255); BACKGROUND-COLOR: transparent; border-image: none" 
                  href="http://web.archive.org/web/20130526162031/http://www.rastertek.com/dx11tut03.html"><STRONG>2013</STRONG></A> 
                </TD>
                <TD id=displayYearEl title="You are here: 9:13:36 Jul 2, 2014" 
                style="FONT-SIZE: 11px !important; HEIGHT: 13px; WIDTH: 34px; BACKGROUND: rgb(0,0,0); FONT-WEIGHT: bold; COLOR: rgb(255,255,0); TEXT-ALIGN: center; PADDING-TOP: 1px">2014</TD>
                <TD 
                style="OVERFLOW: visible; FONT-SIZE: 11px !important; WHITE-SPACE: nowrap; FONT-WEIGHT: bold; PADDING-LEFT: 9px" 
                noWrap>2015 </TD></TR></TBODY></TABLE></TD></TR>
        <TR>
          <TD 
          style="VERTICAL-ALIGN: middle; PADDING-BOTTOM: 0px !important; PADDING-TOP: 0px !important; PADDING-LEFT: 0px !important; PADDING-RIGHT: 0px !important"><A 
            title="See a list of every capture for this URL" 
            style="FONT-SIZE: 11px; FONT-WEIGHT: bold; COLOR: rgb(51,51,255); BACKGROUND-COLOR: transparent; border-image: none" 
            href="http://web.archive.org/web/20140702091336*/http://www.rastertek.com/dx11tut03.html"><STRONG>15 
            captures</STRONG></A> 
            <DIV title="Timespan for captures of this URL" class=__wb_banner_div 
            style="FONT-SIZE: 9px; WHITE-SPACE: nowrap; COLOR: rgb(102,102,102); PADDING-BOTTOM: 0px !important; PADDING-TOP: 2px !important; PADDING-LEFT: 0px !important; MARGIN: 0px; PADDING-RIGHT: 0px !important">19 
            Feb 11 - 22 Jul 14</DIV></TD>
          <TD 
          style="PADDING-BOTTOM: 0px !important; PADDING-TOP: 0px !important; PADDING-LEFT: 0px !important; PADDING-RIGHT: 0px !important"><A 
            id=wm-graph-anchor 
            style="HEIGHT: 27px; WIDTH: 475px; WHITE-SPACE: nowrap; POSITION: relative" 
            href="http://web.archive.org/web/20140702091336/http://www.rastertek.com/">
            <DIV id=wm-ipp-sparkline title="Explore captures for this URL" 
            class=__wb_banner_div 
            style="CURSOR: pointer; HEIGHT: 27px; BORDER-RIGHT: rgb(204,204,204) 1px solid; WIDTH: 475px; WHITE-SPACE: nowrap; POSITION: relative; BACKGROUND-COLOR: rgb(255,255,255)"><IMG 
            onmouseover="showTrackers('inline');" 
            onmousemove=trackMouseMove(event,this) 
            onmouseout="showTrackers('none');" id=sparklineImgId 
            style="POSITION: absolute; LEFT: 0px; Z-INDEX: 9012; TOP: 0px" 
            border=0 alt=sparklines 
            src="Tutorial%203%20Initializing%20DirectX%2011_files/mhtC2E8(1).tmp" 
            width=475 height=27> <IMG id=wbMouseTrackYearImg 
            style="POSITION: absolute; Z-INDEX: 9010; DISPLAY: none" border=0 
            src="Tutorial%203%20Initializing%20DirectX%2011_files/mhtC2FB(1).tmp" 
            width=25 height=27> <IMG id=wbMouseTrackMonthImg 
            style="POSITION: absolute; Z-INDEX: 9011; DISPLAY: none" border=0 
            src="Tutorial%203%20Initializing%20DirectX%2011_files/mhtC2FE(1).tmp" 
            width=2 height=27> </DIV></A></TD></TR></TBODY></TABLE></TD>
    <TD 
    style="FONT-SIZE: 11px !important; WIDTH: 65px; PADDING-BOTTOM: 5px; TEXT-ALIGN: right; PADDING-TOP: 5px; PADDING-LEFT: 5px; PADDING-RIGHT: 5px"><A 
      onclick="document.getElementById('wm-ipp').style.display='none';" 
      title="Close the toolbar" 
      style='MARGIN-BOTTOM: 23px; FONT-FAMILY: "Lucida Grande","Arial",sans-serif; BACKGROUND: url(/static/images/toolbar/wm_tb_close.png) no-repeat 100% 0px; COLOR: rgb(51,51,255); DISPLAY: block; PADDING-RIGHT: 18px; border-image: none' 
      href="javascript:;">Close</A><A 
      title="Get some help using the Wayback Machine" 
      style='FONT-FAMILY: "Lucida Grande","Arial",sans-serif; BACKGROUND: url(/static/images/toolbar/wm_tb_help.png) no-repeat 100% 0px; COLOR: rgb(51,51,255); DISPLAY: block; PADDING-RIGHT: 18px; border-image: none' 
      href="http://faq.web.archive.org/">Help</A></TD></TR></TBODY></TABLE></DIV></DIV>
<SCRIPT type=text/javascript>
 var wmDisclaimBanner = document.getElementById("wm-ipp");
 if(wmDisclaimBanner != null) {
   disclaimElement(wmDisclaimBanner);
 }
</SCRIPT>
<!-- END WAYBACK TOOLBAR INSERT -->
<P align=left><FONT color=#ffffff size=4 face=Arial><B>Tutorial 3: Initializing 
DirectX 11 </B></FONT></P>
<P align=left><IMG border=0 
src="Tutorial%203%20Initializing%20DirectX%2011_files/mhtC310(1).tmp" width=800 
height=1></P>
<P align=left><FONT color=#ffffff size=2 face=Arial>This tutorial will be the 
first introduction to working with DirectX 11. We will address how to initialize 
and shut down Direct3D as well as how to render to a window. </FONT></P><BR>
<P align=left><FONT color=#ffffff size=3 face=Arial><U>Updated 
Framework</U></FONT></P>
<P align=left><FONT color=#ffffff size=2 face=Arial>We are going to add another 
class to the framework which will handle all the Direct3D system functions. We 
will call the class D3DClass. I have updated the framework diagram below: 
</FONT></P>
<P align=left><IMG border=0 
src="Tutorial%203%20Initializing%20DirectX%2011_files/mhtC313(1).tmp" width=198 
height=170></P>
<P align=left><FONT color=#ffffff size=2 face=Arial>As you can see the D3DClass 
will be located inside the GraphicsClass. The previous tutorial mentioned that 
all new graphics related classes will be encapsulated in the GraphicsClass and 
that is why it is the best location for the new D3DClass. Now lets take a look 
at the changes made to the GraphicsClass: </FONT></P><BR>
<P align=left><FONT color=#ffffff size=3 
face=Arial><U>Graphicsclass.h</U></FONT></P><PRE><FONT color=#aaffaa size=2 face=arial>////////////////////////////////////////////////////////////////////////////////
// Filename: graphicsclass.h
////////////////////////////////////////////////////////////////////////////////
#ifndef _GRAPHICSCLASS_H_
#define _GRAPHICSCLASS_H_
</FONT></PRE>
<P align=left><FONT color=#ffffff size=2 face=Arial>Here is the first change. We 
have taken out the include for windows.h and instead included the new 
d3dclass.h. </FONT></P><PRE><FONT color=#aaaaff size=2 face=arial>///////////////////////
// MY CLASS INCLUDES //
///////////////////////
#include "d3dclass.h"
</FONT></PRE><PRE><FONT color=#aaffaa size=2 face=arial>/////////////
// GLOBALS //
/////////////
const bool FULL_SCREEN = false;
const bool VSYNC_ENABLED = true;
const float SCREEN_DEPTH = 1000.0f;
const float SCREEN_NEAR = 0.1f;


////////////////////////////////////////////////////////////////////////////////
// Class name: GraphicsClass
////////////////////////////////////////////////////////////////////////////////
class GraphicsClass
{
public:
	GraphicsClass();
	GraphicsClass(const GraphicsClass&amp;);
	~GraphicsClass();

	bool Initialize(int, int, HWND);
	void Shutdown();
	bool Frame();

private:
	bool Render();

private:
</FONT></PRE>
<P align=left><FONT color=#ffffff size=2 face=Arial>And the second change is the 
new private pointer to the D3DClass which we have called m_D3D. In case you were 
wondering I use the prefix m_ on all class variables. That way when I'm coding I 
can remember quickly what variables are members of the class and which are not. 
</FONT></P><PRE><FONT color=#aaaaff size=2 face=arial>	D3DClass* m_D3D;</FONT>
<FONT color=#aaffaa size=2 face=arial>};

#endif
</FONT></PRE><BR>
<P align=left><FONT color=#ffffff size=3 
face=Arial><U>Graphicsclass.cpp</U></FONT></P>
<P align=left><FONT color=#ffffff size=2 face=Arial>If you'll remember from the 
previous tutorial this class was entirely empty with no code in it at all. Now 
that we have a D3DClass member we will start to fill out some code inside the 
GraphicsClass to initialize and shutdown the D3DClass object. We will also add 
calls to BeginScene and EndScene in the Render function so that we are now 
drawing to the window using Direct3D. </FONT></P>
<P align=left><FONT color=#ffffff size=2 face=Arial>So the very first change is 
in the class constructor. Here we initialize the pointer to null for safety 
reasons as we do with all class pointers. </FONT></P><PRE><FONT color=#aaffaa size=2 face=arial>GraphicsClass::GraphicsClass()
{</FONT>
<FONT color=#aaaaff size=2 face=arial>	m_D3D = 0;</FONT>
<FONT color=#aaffaa size=2 face=arial>}
</FONT></PRE>
<P align=left><FONT color=#ffffff size=2 face=Arial>The second change is in the 
Initialize function inside the GraphicsClass. Here we create the D3DClass object 
and then call the D3DClass Initialize function. We send this function the screen 
width, screen height, handle to the window, and the four global variables from 
the Graphicsclass.h file. The D3DClass will use all these variables to setup the 
Direct3D system. We'll go into more detail about that once we look at the 
d3dclass.cpp file. </FONT></P><PRE><FONT color=#aaffaa size=2 face=arial>bool GraphicsClass::Initialize(int screenWidth, int screenHeight, HWND hwnd)
{</FONT><FONT color=#aaaaff size=2 face=arial>
	bool result;

		
	// Create the Direct3D object.
	m_D3D = new D3DClass;
	if(!m_D3D)
	{
		return false;
	}

	// Initialize the Direct3D object.
	result = m_D3D-&gt;Initialize(screenWidth, screenHeight, VSYNC_ENABLED, hwnd, FULL_SCREEN, SCREEN_DEPTH, SCREEN_NEAR);
	if(!result)
	{
		MessageBox(hwnd, L"Could not initialize Direct3D", L"Error", MB_OK);
		return false;
	}</FONT><FONT color=#aaffaa size=2 face=arial>

	return true;
}
</FONT></PRE>
<P align=left><FONT color=#ffffff size=2 face=Arial>The next change is in the 
Shutdown function in the GraphicsClass. Shut down of all graphics objects occur 
here so we have placed the D3DClass shutdown in this function. Note that I check 
to see if the pointer was initialized or not. If it wasn't we can assume it was 
never set up and not try to shut it down. That is why it is important to set all 
the pointers to null in the class constructor. If it does find the pointer has 
been initialized then it will attempt to shut down the D3DClass and then clean 
up the pointer afterwards. </FONT></P><PRE><FONT color=#aaffaa size=2 face=arial>void GraphicsClass::Shutdown()
{</FONT><FONT color=#aaaaff size=2 face=arial>
	if(m_D3D)
	{
		m_D3D-&gt;Shutdown();
		delete m_D3D;
		m_D3D = 0;
	}</FONT><FONT color=#aaffaa size=2 face=arial>

	return;
}
</FONT></PRE>
<P align=left><FONT color=#ffffff size=2 face=Arial>The Frame function has been 
updated so that it now calls the Render function each frame. </FONT></P><PRE><FONT color=#aaffaa size=2 face=arial>bool GraphicsClass::Frame()
{</FONT><FONT color=#aaaaff size=2 face=arial>
	bool result;


	// Render the graphics scene.
	result = Render();
	if(!result)
	{
		return false;
	}</FONT><FONT color=#aaffaa size=2 face=arial>

	return true;
}
</FONT></PRE>
<P align=left><FONT color=#ffffff size=2 face=Arial>The final change to this 
class is in the Render function. We call the D3D object to clear the screen to a 
grey color. After that we call EndScene so that the grey color is presented to 
the window. </FONT></P><PRE><FONT color=#aaffaa size=2 face=arial>bool GraphicsClass::Render()
{</FONT><FONT color=#aaaaff size=2 face=arial>
	// Clear the buffers to begin the scene.
	m_D3D-&gt;BeginScene(0.5f, 0.5f, 0.5f, 1.0f);


	// Present the rendered scene to the screen.
	m_D3D-&gt;EndScene();</FONT><FONT color=#aaffaa size=2 face=arial>

	return true;
}
</FONT></PRE>
<P align=left><FONT color=#ffffff size=2 face=Arial>Now lets take a look at the 
new D3DClass header file: </FONT></P><BR>
<P align=left><FONT color=#ffffff size=3 face=Arial><U>D3dclass.h</U></FONT></P><PRE><FONT color=#aaffaa size=2 face=arial>////////////////////////////////////////////////////////////////////////////////
// Filename: d3dclass.h
////////////////////////////////////////////////////////////////////////////////
#ifndef _D3DCLASS_H_
#define _D3DCLASS_H_
</FONT></PRE>
<P align=left><FONT color=#ffffff size=2 face=Arial>First thing in the header is 
to specify the libraries to link when using this object module. These libraries 
contain all the Direct3D functionality for setting up and drawing 3D graphics in 
DirectX as well as tools to interface with the hardware on the computer to 
obtain information about the refresh rate of the monitor, the video card being 
used, and so forth. You will notice that some DirectX 10 libraries are still 
used, this is because those libraries were never upgraded for DirectX 11 as 
their functionality did not need to change. </FONT></P><PRE><FONT color=#aaffaa size=2 face=arial>/////////////
// LINKING //
/////////////
#pragma comment(lib, "dxgi.lib")
#pragma comment(lib, "d3d11.lib")
#pragma comment(lib, "d3dx11.lib")
#pragma comment(lib, "d3dx10.lib")
</FONT></PRE>
<P align=left><FONT color=#ffffff size=2 face=Arial>The next thing we do is 
include the headers for those libraries that we are linking to this object 
module as well as headers for DirectX type definitions and such. </FONT></P><PRE><FONT color=#aaffaa size=2 face=arial>//////////////
// INCLUDES //
//////////////
#include &lt;dxgi.h&gt;
#include &lt;d3dcommon.h&gt;
#include &lt;d3d11.h&gt;
#include &lt;d3dx10math.h&gt;
</FONT></PRE>
<P align=left><FONT color=#ffffff size=2 face=Arial>The class definition for the 
D3DClass is kept as simple as possible here. It has the regular constructor, 
copy constructor, and destructor. Then more importantly it has the Initialize 
and Shutdown function. This will be what we are mainly focused on in this 
tutorial. Other than that I have a couple helper functions which aren't 
important to this tutorial and a number of private member variables that will be 
looked at when we examine the d3dclass.cpp file. For now just realize the 
Initialize and Shutdown functions are what concerns us. </FONT></P><PRE><FONT color=#aaffaa size=2 face=arial>////////////////////////////////////////////////////////////////////////////////
// Class name: D3DClass
////////////////////////////////////////////////////////////////////////////////
class D3DClass
{
public:
	D3DClass();
	D3DClass(const D3DClass&amp;);
	~D3DClass();

	bool Initialize(int, int, bool, HWND, bool, float, float);
	void Shutdown();
	
	void BeginScene(float, float, float, float);
	void EndScene();

	ID3D11Device* GetDevice();
	ID3D11DeviceContext* GetDeviceContext();

	void GetProjectionMatrix(D3DXMATRIX&amp;);
	void GetWorldMatrix(D3DXMATRIX&amp;);
	void GetOrthoMatrix(D3DXMATRIX&amp;);

	void GetVideoCardInfo(char*, int&amp;);

private:
	bool m_vsync_enabled;
	int m_videoCardMemory;
	char m_videoCardDescription[128];
	IDXGISwapChain* m_swapChain;
	ID3D11Device* m_device;
	ID3D11DeviceContext* m_deviceContext;
	ID3D11RenderTargetView* m_renderTargetView;
	ID3D11Texture2D* m_depthStencilBuffer;
	ID3D11DepthStencilState* m_depthStencilState;
	ID3D11DepthStencilView* m_depthStencilView;
	ID3D11RasterizerState* m_rasterState;
	D3DXMATRIX m_projectionMatrix;
	D3DXMATRIX m_worldMatrix;
	D3DXMATRIX m_orthoMatrix;
};

#endif
</FONT></PRE>
<P align=left><FONT color=#ffffff size=2 face=Arial>For those familiar with 
Direct3D already you may notice I don't have a view matrix variable in this 
class. The reason being is that I will be putting it in a camera class that we 
will be looking at in future tutorials. </FONT></P><BR>
<P align=left><FONT color=#ffffff size=3 
face=Arial><U>D3dclass.cpp</U></FONT></P><PRE><FONT color=#aaffaa size=2 face=arial>////////////////////////////////////////////////////////////////////////////////
// Filename: d3dclass.cpp
////////////////////////////////////////////////////////////////////////////////
#include "d3dclass.h"
</FONT></PRE>
<P align=left><FONT color=#ffffff size=2 face=Arial>So like most classes we 
begin with initializing all the member pointers to null in the class 
constructor. All pointers from the header file have all been accounted for here. 
</FONT></P><PRE><FONT color=#aaffaa size=2 face=arial>D3DClass::D3DClass()
{
	m_swapChain = 0;
	m_device = 0;
	m_deviceContext = 0;
	m_renderTargetView = 0;
	m_depthStencilBuffer = 0;
	m_depthStencilState = 0;
	m_depthStencilView = 0;
	m_rasterState = 0;
}


D3DClass::D3DClass(const D3DClass&amp; other)
{
}


D3DClass::~D3DClass()
{
}
</FONT></PRE>
<P align=left><FONT color=#ffffff size=2 face=Arial>The Initialize function is 
what does the entire setup of Direct3D for DirectX 11. I have placed all the 
code necessary in here as well as some extra stuff that will facilitate future 
tutorials. I could have simplified it and taken out some items but it is 
probably better to get all of this covered in a single tutorial dedicated to it. 
</FONT></P>
<P align=left><FONT color=#ffffff size=2 face=Arial>The screenWidth and 
screenHeight variables that are given to this function are the width and height 
of the window we created in the SystemClass. Direct3D will use these to 
initialize and use the same window dimensions. The hwnd variable is a handle to 
the window. Direct3D will need this handle to access the window previously 
created. The fullscreen variable is whether we are running in windowed mode or 
fullscreen. Direct3D needs this as well for creating the window with the correct 
settings. The screenDepth and screenNear variables are the depth settings for 
our 3D environment that will be rendered in the window. The vsync variable 
indicates if we want Direct3D to render according to the users monitor refresh 
rate or to just go as fast as possible. </FONT></P><PRE><FONT color=#aaffaa size=2 face=arial>bool D3DClass::Initialize(int screenWidth, int screenHeight, bool vsync, HWND hwnd, bool fullscreen, 
			  float screenDepth, float screenNear)
{
	HRESULT result;
	IDXGIFactory* factory;
	IDXGIAdapter* adapter;
	IDXGIOutput* adapterOutput;
	unsigned int numModes, i, numerator, denominator, stringLength;
	DXGI_MODE_DESC* displayModeList;
	DXGI_ADAPTER_DESC adapterDesc;
	int error;
	DXGI_SWAP_CHAIN_DESC swapChainDesc;
	D3D_FEATURE_LEVEL featureLevel;
	ID3D11Texture2D* backBufferPtr;
	D3D11_TEXTURE2D_DESC depthBufferDesc;
	D3D11_DEPTH_STENCIL_DESC depthStencilDesc;
	D3D11_DEPTH_STENCIL_VIEW_DESC depthStencilViewDesc;
	D3D11_RASTERIZER_DESC rasterDesc;
	D3D11_VIEWPORT viewport;
	float fieldOfView, screenAspect;


	// Store the vsync setting.
	m_vsync_enabled = vsync;
</FONT></PRE>
<P align=left><FONT color=#ffffff size=2 face=Arial>Before we can initialize 
Direct3D we have to get the refresh rate from the video card/monitor. Each 
computer may be slightly different so we will need to query for that 
information. We query for the numerator and denominator values and then pass 
them to DirectX during the setup and it will calculate the proper refresh rate. 
If we don't do this and just set the refresh rate to a default value which may 
not exist on all computers then DirectX will respond by performing a blit 
instead of a buffer flip which will degrade performance and give us annoying 
errors in the debug output. </FONT></P><PRE><FONT color=#aaffaa size=2 face=arial>	// Create a DirectX graphics interface factory.
	result = CreateDXGIFactory(__uuidof(IDXGIFactory), (void**)&amp;factory);
	if(FAILED(result))
	{
		return false;
	}

	// Use the factory to create an adapter for the primary graphics interface (video card).
	result = factory-&gt;EnumAdapters(0, &amp;adapter);
	if(FAILED(result))
	{
		return false;
	}

	// Enumerate the primary adapter output (monitor).
	result = adapter-&gt;EnumOutputs(0, &amp;adapterOutput);
	if(FAILED(result))
	{
		return false;
	}

	// Get the number of modes that fit the DXGI_FORMAT_R8G8B8A8_UNORM display format for the adapter output (monitor).
	result = adapterOutput-&gt;GetDisplayModeList(DXGI_FORMAT_R8G8B8A8_UNORM, DXGI_ENUM_MODES_INTERLACED, &amp;numModes, NULL);
	if(FAILED(result))
	{
		return false;
	}

	// Create a list to hold all the possible display modes for this monitor/video card combination.
	displayModeList = new DXGI_MODE_DESC[numModes];
	if(!displayModeList)
	{
		return false;
	}

	// Now fill the display mode list structures.
	result = adapterOutput-&gt;GetDisplayModeList(DXGI_FORMAT_R8G8B8A8_UNORM, DXGI_ENUM_MODES_INTERLACED, &amp;numModes, displayModeList);
	if(FAILED(result))
	{
		return false;
	}

	// Now go through all the display modes and find the one that matches the screen width and height.
	// When a match is found store the numerator and denominator of the refresh rate for that monitor.
	for(i=0; i&lt;numModes; i++)
	{
		if(displayModeList[i].Width == (unsigned int)screenWidth)
		{
			if(displayModeList[i].Height == (unsigned int)screenHeight)
			{
				numerator = displayModeList[i].RefreshRate.Numerator;
				denominator = displayModeList[i].RefreshRate.Denominator;
			}
		}
	}
</FONT></PRE>
<P align=left><FONT color=#ffffff size=2 face=Arial>We now have the numerator 
and denominator for the refresh rate. The last thing we will retrieve using the 
adapter is the name of the video card and the amount of memory on the video 
card. </FONT></P><PRE><FONT color=#aaffaa size=2 face=arial>	// Get the adapter (video card) description.
	result = adapter-&gt;GetDesc(&amp;adapterDesc);
	if(FAILED(result))
	{
		return false;
	}

	// Store the dedicated video card memory in megabytes.
	m_videoCardMemory = (int)(adapterDesc.DedicatedVideoMemory / 1024 / 1024);

	// Convert the name of the video card to a character array and store it.
	error = wcstombs_s(&amp;stringLength, m_videoCardDescription, 128, adapterDesc.Description, 128);
	if(error != 0)
	{
		return false;
	}
</FONT></PRE>
<P align=left><FONT color=#ffffff size=2 face=Arial>Now that we have stored the 
numerator and denominator for the refresh rate and the video card information we 
can release the structures and interfaces used to get that information. 
</FONT></P><PRE><FONT color=#aaffaa size=2 face=arial>	// Release the display mode list.
	delete [] displayModeList;
	displayModeList = 0;

	// Release the adapter output.
	adapterOutput-&gt;Release();
	adapterOutput = 0;

	// Release the adapter.
	adapter-&gt;Release();
	adapter = 0;

	// Release the factory.
	factory-&gt;Release();
	factory = 0;
</FONT></PRE>
<P align=left><FONT color=#ffffff size=2 face=Arial>Now that we have the refresh 
rate from the system we can start the DirectX initialization. The first thing 
we'll do is fill out the description of the swap chain. The swap chain is the 
front and back buffer to which the graphics will be drawn. Generally you use a 
single back buffer, do all your drawing to it, and then <B>swap</B> it to the 
front buffer which then displays on the user's screen. That is why it is called 
a swap chain. </FONT></P><PRE><FONT color=#aaffaa size=2 face=arial>	// Initialize the swap chain description.
	ZeroMemory(&amp;swapChainDesc, sizeof(swapChainDesc));

	// Set to a single back buffer.
	swapChainDesc.BufferCount = 1;

	// Set the width and height of the back buffer.
	swapChainDesc.BufferDesc.Width = screenWidth;
	swapChainDesc.BufferDesc.Height = screenHeight;

	// Set regular 32-bit surface for the back buffer.
	swapChainDesc.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
</FONT></PRE>
<P align=left><FONT color=#ffffff size=2 face=Arial>The next part of the 
description of the swap chain is the refresh rate. The refresh rate is how many 
times a second it draws the back buffer to the front buffer. If vsync is set to 
true in our graphicsclass.h header then this will lock the refresh rate to the 
system settings (for example 60hz). That means it will only draw the screen 60 
times a second (or higher if the system refresh rate is more than 60). However 
if we set vsync to false then it will draw the screen as many times a second as 
it can, however this can cause some visual artifacts. </FONT></P><PRE><FONT color=#aaffaa size=2 face=arial>	// Set the refresh rate of the back buffer.
	if(m_vsync_enabled)
	{
		swapChainDesc.BufferDesc.RefreshRate.Numerator = numerator;
		swapChainDesc.BufferDesc.RefreshRate.Denominator = denominator;
	}
	else
	{
		swapChainDesc.BufferDesc.RefreshRate.Numerator = 0;
		swapChainDesc.BufferDesc.RefreshRate.Denominator = 1;
	}

	// Set the usage of the back buffer.
	swapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;

	// Set the handle for the window to render to.
	swapChainDesc.OutputWindow = hwnd;

	// Turn multisampling off.
	swapChainDesc.SampleDesc.Count = 1;
	swapChainDesc.SampleDesc.Quality = 0;

	// Set to full screen or windowed mode.
	if(fullscreen)
	{
		swapChainDesc.Windowed = false;
	}
	else
	{
		swapChainDesc.Windowed = true;
	}

	// Set the scan line ordering and scaling to unspecified.
	swapChainDesc.BufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;
	swapChainDesc.BufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;

	// Discard the back buffer contents after presenting.
	swapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;

	// Don't set the advanced flags.
	swapChainDesc.Flags = 0;
</FONT></PRE>
<P align=left><FONT color=#ffffff size=2 face=Arial>After setting up the swap 
chain description we also need to setup one more variable called the feature 
level. This variable tells DirectX what version we plan to use. Here we set the 
feature level to 11.0 which is DirectX 11. You can set this to 10 or 9 to use a 
lower level version of DirectX if you plan on supporting multiple versions or 
running on lower end hardware. </FONT></P><PRE><FONT color=#aaffaa size=2 face=arial>	// Set the feature level to DirectX 11.
	featureLevel = D3D_FEATURE_LEVEL_11_0;
</FONT></PRE>
<P align=left><FONT color=#ffffff size=2 face=Arial>Now that the swap chain 
description and feature level have been filled out we can create the swap chain, 
the Direct3D device, and the Direct3D device context. The Direct3D device and 
Direct3D device context are very important, they are the interface to all of the 
Direct3D functions. We will use the device and device context for almost 
everything from this point forward. </FONT></P>
<P align=left><FONT color=#ffffff size=2 face=Arial>Those of you reading this 
who are familiar with the previous versions of DirectX will recognize the 
Direct3D device but will be unfamiliar with the new Direct3D device context. 
Basically they took the functionality of the Direct3D device and split it up 
into two different devices so you need to use both now. </FONT></P>
<P align=left><FONT color=#ffffff size=2 face=Arial>Note that if the user does 
not have a DirectX 11 video card this function call will fail to create the 
device and device context. Also if you are testing DirectX 11 functionality 
yourself and don't have a DirectX 11 video card then you can replace 
D3D_DRIVER_TYPE_HARDWARE with D3D_DRIVER_TYPE_REFERENCE and DirectX will use 
your CPU to draw instead of the video card hardware. Note that this runs 1/1000 
the speed but it is good for people who don't have DirectX 11 video cards yet on 
all their machines. </FONT></P><PRE><FONT color=#aaffaa size=2 face=arial>	// Create the swap chain, Direct3D device, and Direct3D device context.
	result = D3D11CreateDeviceAndSwapChain(NULL, D3D_DRIVER_TYPE_HARDWARE, NULL, 0, &amp;featureLevel, 1, 
					       D3D11_SDK_VERSION, &amp;swapChainDesc, &amp;m_swapChain, &amp;m_device, NULL, &amp;m_deviceContext);
	if(FAILED(result))
	{
		return false;
	}
</FONT></PRE>
<P align=left><FONT color=#ffffff size=2 face=Arial>Sometimes this call to 
create the device will fail if the primary video card is not compatible with 
DirectX 11. Some machines may have the primary card as a DirectX 10 video card 
and the secondary card as a DirectX 11 video card. Also some hybrid graphics 
cards work that way with the primary being the low power Intel card and the 
secondary being the high power Nvidia card. To get around this you will need to 
not use the default device and instead enumerate all the video cards in the 
machine and have the user choose which one to use and then specify that card 
when creating the device. </FONT></P>
<P align=left><FONT color=#ffffff size=2 face=Arial>Now that we have a swap 
chain we need to get a pointer to the back buffer and then attach it to the swap 
chain. We'll use the CreateRenderTargetView function to attach the back buffer 
to our swap chain. </FONT></P><PRE><FONT color=#aaffaa size=2 face=arial>	// Get the pointer to the back buffer.
	result = m_swapChain-&gt;GetBuffer(0, __uuidof(ID3D11Texture2D), (LPVOID*)&amp;backBufferPtr);
	if(FAILED(result))
	{
		return false;
	}

	// Create the render target view with the back buffer pointer.
	result = m_device-&gt;CreateRenderTargetView(backBufferPtr, NULL, &amp;m_renderTargetView);
	if(FAILED(result))
	{
		return false;
	}

	// Release pointer to the back buffer as we no longer need it.
	backBufferPtr-&gt;Release();
	backBufferPtr = 0;
</FONT></PRE>
<P align=left><FONT color=#ffffff size=2 face=Arial>We will also need to set up 
a depth buffer description. We'll use this to create a depth buffer so that our 
polygons can be rendered properly in 3D space. At the same time we will attach a 
stencil buffer to our depth buffer. The stencil buffer can be used to achieve 
effects such as motion blur, volumetric shadows, and other things. </FONT></P><PRE><FONT color=#aaffaa size=2 face=arial>	// Initialize the description of the depth buffer.
	ZeroMemory(&amp;depthBufferDesc, sizeof(depthBufferDesc));

	// Set up the description of the depth buffer.
	depthBufferDesc.Width = screenWidth;
	depthBufferDesc.Height = screenHeight;
	depthBufferDesc.MipLevels = 1;
	depthBufferDesc.ArraySize = 1;
	depthBufferDesc.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;
	depthBufferDesc.SampleDesc.Count = 1;
	depthBufferDesc.SampleDesc.Quality = 0;
	depthBufferDesc.Usage = D3D11_USAGE_DEFAULT;
	depthBufferDesc.BindFlags = D3D11_BIND_DEPTH_STENCIL;
	depthBufferDesc.CPUAccessFlags = 0;
	depthBufferDesc.MiscFlags = 0;
</FONT></PRE>
<P align=left><FONT color=#ffffff size=2 face=Arial>Now we create the 
depth/stencil buffer using that description. You will notice we use the 
CreateTexture2D function to make the buffers, hence the buffer is just a 2D 
texture. The reason for this is that once your polygons are sorted and then 
rasterized they just end up being colored pixels in this 2D buffer. Then this 2D 
buffer is drawn to the screen. </FONT></P><PRE><FONT color=#aaffaa size=2 face=arial>	// Create the texture for the depth buffer using the filled out description.
	result = m_device-&gt;CreateTexture2D(&amp;depthBufferDesc, NULL, &amp;m_depthStencilBuffer);
	if(FAILED(result))
	{
		return false;
	}
</FONT></PRE>
<P align=left><FONT color=#ffffff size=2 face=Arial>Now we need to setup the 
depth stencil description. This allows us to control what type of depth test 
Direct3D will do for each pixel. </FONT></P><PRE><FONT color=#aaffaa size=2 face=arial>	// Initialize the description of the stencil state.
	ZeroMemory(&amp;depthStencilDesc, sizeof(depthStencilDesc));

	// Set up the description of the stencil state.
	depthStencilDesc.DepthEnable = true;
	depthStencilDesc.DepthWriteMask = D3D11_DEPTH_WRITE_MASK_ALL;
	depthStencilDesc.DepthFunc = D3D11_COMPARISON_LESS;

	depthStencilDesc.StencilEnable = true;
	depthStencilDesc.StencilReadMask = 0xFF;
	depthStencilDesc.StencilWriteMask = 0xFF;

	// Stencil operations if pixel is front-facing.
	depthStencilDesc.FrontFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
	depthStencilDesc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_INCR;
	depthStencilDesc.FrontFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
	depthStencilDesc.FrontFace.StencilFunc = D3D11_COMPARISON_ALWAYS;

	// Stencil operations if pixel is back-facing.
	depthStencilDesc.BackFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
	depthStencilDesc.BackFace.StencilDepthFailOp = D3D11_STENCIL_OP_DECR;
	depthStencilDesc.BackFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
	depthStencilDesc.BackFace.StencilFunc = D3D11_COMPARISON_ALWAYS;
</FONT></PRE>
<P align=left><FONT color=#ffffff size=2 face=Arial>With the description filled 
out we can now create a depth stencil state. </FONT></P><PRE><FONT color=#aaffaa size=2 face=arial>	// Create the depth stencil state.
	result = m_device-&gt;CreateDepthStencilState(&amp;depthStencilDesc, &amp;m_depthStencilState);
	if(FAILED(result))
	{
		return false;
	}
</FONT></PRE>
<P align=left><FONT color=#ffffff size=2 face=Arial>With the created depth 
stencil state we can now set it so that it takes effect. Notice we use the 
device context to set it. </FONT></P><PRE><FONT color=#aaffaa size=2 face=arial>	// Set the depth stencil state.
	m_deviceContext-&gt;OMSetDepthStencilState(m_depthStencilState, 1);
</FONT></PRE>
<P align=left><FONT color=#ffffff size=2 face=Arial>The next thing we need to 
create is the description of the view of the depth stencil buffer. We do this so 
that Direct3D knows to use the depth buffer as a depth stencil texture. After 
filling out the description we then call the function CreateDepthStencilView to 
create it. </FONT></P><PRE><FONT color=#aaffaa size=2 face=arial>	// Initailze the depth stencil view.
	ZeroMemory(&amp;depthStencilViewDesc, sizeof(depthStencilViewDesc));

	// Set up the depth stencil view description.
	depthStencilViewDesc.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;
	depthStencilViewDesc.ViewDimension = D3D11_DSV_DIMENSION_TEXTURE2D;
	depthStencilViewDesc.Texture2D.MipSlice = 0;

	// Create the depth stencil view.
	result = m_device-&gt;CreateDepthStencilView(m_depthStencilBuffer, &amp;depthStencilViewDesc, &amp;m_depthStencilView);
	if(FAILED(result))
	{
		return false;
	}
</FONT></PRE>
<P align=left><FONT color=#ffffff size=2 face=Arial>With that created we can now 
call OMSetRenderTargets. This will bind the render target view and the depth 
stencil buffer to the output render pipeline. This way the graphics that the 
pipeline renders will get drawn to our back buffer that we previously created. 
With the graphics written to the back buffer we can then swap it to the front 
and display our graphics on the user's screen. </FONT></P><PRE><FONT color=#aaffaa size=2 face=arial>	// Bind the render target view and depth stencil buffer to the output render pipeline.
	m_deviceContext-&gt;OMSetRenderTargets(1, &amp;m_renderTargetView, m_depthStencilView);
</FONT></PRE>
<P align=left><FONT color=#ffffff size=2 face=Arial>Now that the render targets 
are setup we can continue on to some extra functions that will give us more 
control over our scenes for future tutorials. First thing is we'll create is a 
rasterizer state. This will give us control over how polygons are rendered. We 
can do things like make our scenes render in wireframe mode or have DirectX draw 
both the front and back faces of polygons. By default DirectX already has a 
rasterizer state set up and working the exact same as the one below but you have 
no control to change it unless you set up one yourself. </FONT></P><PRE><FONT color=#aaffaa size=2 face=arial>	// Setup the raster description which will determine how and what polygons will be drawn.
	rasterDesc.AntialiasedLineEnable = false;
	rasterDesc.CullMode = D3D11_CULL_BACK;
	rasterDesc.DepthBias = 0;
	rasterDesc.DepthBiasClamp = 0.0f;
	rasterDesc.DepthClipEnable = true;
	rasterDesc.FillMode = D3D11_FILL_SOLID;
	rasterDesc.FrontCounterClockwise = false;
	rasterDesc.MultisampleEnable = false;
	rasterDesc.ScissorEnable = false;
	rasterDesc.SlopeScaledDepthBias = 0.0f;

	// Create the rasterizer state from the description we just filled out.
	result = m_device-&gt;CreateRasterizerState(&amp;rasterDesc, &amp;m_rasterState);
	if(FAILED(result))
	{
		return false;
	}

	// Now set the rasterizer state.
	m_deviceContext-&gt;RSSetState(m_rasterState);
</FONT></PRE>
<P align=left><FONT color=#ffffff size=2 face=Arial>The viewport also needs to 
be setup so that Direct3D can map clip space coordinates to the render target 
space. Set this to be the entire size of the window. </FONT></P><PRE><FONT color=#aaffaa size=2 face=arial>	// Setup the viewport for rendering.
	viewport.Width = (float)screenWidth;
	viewport.Height = (float)screenHeight;
	viewport.MinDepth = 0.0f;
	viewport.MaxDepth = 1.0f;
	viewport.TopLeftX = 0.0f;
	viewport.TopLeftY = 0.0f;

	// Create the viewport.
	m_deviceContext-&gt;RSSetViewports(1, &amp;viewport);
</FONT></PRE>
<P align=left><FONT color=#ffffff size=2 face=Arial>Now we will create the 
projection matrix. The projection matrix is used to translate the 3D scene into 
the 2D viewport space that we previously created. We will need to keep a copy of 
this matrix so that we can pass it to our shaders that will be used to render 
our scenes. </FONT></P><PRE><FONT color=#aaffaa size=2 face=arial>	// Setup the projection matrix.
	fieldOfView = (float)D3DX_PI / 4.0f;
	screenAspect = (float)screenWidth / (float)screenHeight;

	// Create the projection matrix for 3D rendering.
	D3DXMatrixPerspectiveFovLH(&amp;m_projectionMatrix, fieldOfView, screenAspect, screenNear, screenDepth);
</FONT></PRE>
<P align=left><FONT color=#ffffff size=2 face=Arial>We will also create another 
matrix called the world matrix. This matrix is used to convert the vertices of 
our objects into vertices in the 3D scene. This matrix will also be used to 
rotate, translate, and scale our objects in 3D space. From the start we will 
just initialize the matrix to the identity matrix and keep a copy of it in this 
object. The copy will be needed to be passed to the shaders for rendering also. 
</FONT></P><PRE><FONT color=#aaffaa size=2 face=arial>	// Initialize the world matrix to the identity matrix.
	D3DXMatrixIdentity(&amp;m_worldMatrix);
</FONT></PRE>
<P align=left><FONT color=#ffffff size=2 face=Arial>This is where you would 
generally create a view matrix. The view matrix is used to calculate the 
position of where we are looking at the scene from. You can think of it as a 
camera and you only view the scene through this camera. Because of its purpose I 
am going to create it in a camera class in later tutorials since logically it 
fits better there and just skip it for now. </FONT></P>
<P align=left><FONT color=#ffffff size=2 face=Arial>And the final thing we will 
setup in the Initialize function is an orthographic projection matrix. This 
matrix is used for rendering 2D elements like user interfaces on the screen 
allowing us to skip the 3D rendering. You will see this used in later tutorials 
when we look at rendering 2D graphics and fonts to the screen. </FONT></P><PRE><FONT color=#aaffaa size=2 face=arial>	// Create an orthographic projection matrix for 2D rendering.
	D3DXMatrixOrthoLH(&amp;m_orthoMatrix, (float)screenWidth, (float)screenHeight, screenNear, screenDepth);

	return true;
}
</FONT></PRE>
<P align=left><FONT color=#ffffff size=2 face=Arial>The Shutdown function will 
release and clean up all the pointers used in the Initialize function, its 
pretty straight forward. However before doing that I put in a call to force the 
swap chain to go into windowed mode first before releasing any pointers. If this 
is not done and you try to release the swap chain in full screen mode it will 
throw some exceptions. So to avoid that happening we just always force windowed 
mode before shutting down Direct3D. </FONT></P><PRE><FONT color=#aaffaa size=2 face=arial>void D3DClass::Shutdown()
{
	// Before shutting down set to windowed mode or when you release the swap chain it will throw an exception.
	if(m_swapChain)
	{
		m_swapChain-&gt;SetFullscreenState(false, NULL);
	}

	if(m_rasterState)
	{
		m_rasterState-&gt;Release();
		m_rasterState = 0;
	}

	if(m_depthStencilView)
	{
		m_depthStencilView-&gt;Release();
		m_depthStencilView = 0;
	}

	if(m_depthStencilState)
	{
		m_depthStencilState-&gt;Release();
		m_depthStencilState = 0;
	}

	if(m_depthStencilBuffer)
	{
		m_depthStencilBuffer-&gt;Release();
		m_depthStencilBuffer = 0;
	}

	if(m_renderTargetView)
	{
		m_renderTargetView-&gt;Release();
		m_renderTargetView = 0;
	}

	if(m_deviceContext)
	{
		m_deviceContext-&gt;Release();
		m_deviceContext = 0;
	}

	if(m_device)
	{
		m_device-&gt;Release();
		m_device = 0;
	}

	if(m_swapChain)
	{
		m_swapChain-&gt;Release();
		m_swapChain = 0;
	}

	return;
}
</FONT></PRE>
<P align=left><FONT color=#ffffff size=2 face=Arial>In the D3DClass I have a 
couple helper functions. The first two are BeginScene and EndScene. BeginScene 
will be called whenever we are going to draw a new 3D scene at the beginning of 
each frame. All it does is initializes the buffers so they are blank and ready 
to be drawn to. The other function is Endscene, it tells the swap chain to 
display our 3D scene once all the drawing has completed at the end of each 
frame. </FONT></P><PRE><FONT color=#aaffaa size=2 face=arial>void D3DClass::BeginScene(float red, float green, float blue, float alpha)
{
	float color[4];


	// Setup the color to clear the buffer to.
	color[0] = red;
	color[1] = green;
	color[2] = blue;
	color[3] = alpha;

	// Clear the back buffer.
	m_deviceContext-&gt;ClearRenderTargetView(m_renderTargetView, color);
    
	// Clear the depth buffer.
	m_deviceContext-&gt;ClearDepthStencilView(m_depthStencilView, D3D11_CLEAR_DEPTH, 1.0f, 0);

	return;
}


void D3DClass::EndScene()
{
	// Present the back buffer to the screen since rendering is complete.
	if(m_vsync_enabled)
	{
		// Lock to screen refresh rate.
		m_swapChain-&gt;Present(1, 0);
	}
	else
	{
		// Present as fast as possible.
		m_swapChain-&gt;Present(0, 0);
	}

	return;
}
</FONT></PRE>
<P align=left><FONT color=#ffffff size=2 face=Arial>These next functions simply 
get pointers to the Direct3D device and the Direct3D device context. These 
helper functions will be called by the framework often. </FONT></P><PRE><FONT color=#aaffaa size=2 face=arial>ID3D11Device* D3DClass::GetDevice()
{
	return m_device;
}


ID3D11DeviceContext* D3DClass::GetDeviceContext()
{
	return m_deviceContext;
}
</FONT></PRE>
<P align=left><FONT color=#ffffff size=2 face=Arial>The next three helper 
functions give copies of the projection, world, and orthographic matrices to 
calling functions. Most shaders will need these matrices for rendering so there 
needed to be an easy way for outside objects to get a copy of them. We won't 
call these functions in this tutorial but I'm just explaining why they are in 
the code. </FONT></P><PRE><FONT color=#aaffaa size=2 face=arial>void D3DClass::GetProjectionMatrix(D3DXMATRIX&amp; projectionMatrix)
{
	projectionMatrix = m_projectionMatrix;
	return;
}


void D3DClass::GetWorldMatrix(D3DXMATRIX&amp; worldMatrix)
{
	worldMatrix = m_worldMatrix;
	return;
}


void D3DClass::GetOrthoMatrix(D3DXMATRIX&amp; orthoMatrix)
{
	orthoMatrix = m_orthoMatrix;
	return;
}
</FONT></PRE>
<P align=left><FONT color=#ffffff size=2 face=Arial>The last helper function 
returns by reference the name of the video card and the amount of dedicated 
memory on the video card. Knowing the video card name and amount of video memory 
can help in debugging on different configurations. </FONT></P><PRE><FONT color=#aaffaa size=2 face=arial>void D3DClass::GetVideoCardInfo(char* cardName, int&amp; memory)
{
	strcpy_s(cardName, 128, m_videoCardDescription);
	memory = m_videoCardMemory;
	return;
}
</FONT></PRE><BR>
<P align=left><FONT color=#ffffff size=3 face=Arial><U>Summary</U></FONT></P>
<P align=left><FONT color=#ffffff size=2 face=Arial>So now we are finally able 
to initialize and shut down Direct3D as well as render a color to the window. 
Compiling and running the code will produce the same window as the last tutorial 
but Direct3D is initialized now and the window is cleared to grey. Compiling and 
running the code will also show if your compiler is set up properly and if it 
can see the headers and libraries files from the DirectX SDK. </FONT></P><BR>
<P align=left><FONT color=#ffffff size=3 face=Arial><U>To Do 
Exercises</U></FONT></P>
<P align=left><FONT color=#ffffff size=2 face=Arial>1. Re-compile the code and 
run the program to ensure DirectX works, if not look at the steps from the first 
tutorial. Press the escape key to quit after the window displays. </FONT></P>
<P align=left><FONT color=#ffffff size=2 face=Arial>2. Change the global in 
graphicsclass.h to full screen and re-compile/run. </FONT></P>
<P align=left><FONT color=#ffffff size=2 face=Arial>3. Change the clear color in 
GraphicsClass::Render to yellow. </FONT></P>
<P align=left><FONT color=#ffffff size=2 face=Arial>4. Write the video card name 
and memory out to a text file. </FONT></P><BR>
<P align=left><FONT color=#ffffff size=3 face=Arial><U>Source 
Code</U></FONT></P>
<P align=left><FONT color=#ffffff size=2 face=Arial>Visual Studio 2010 Project: 
<A 
href="http://web.archive.org/web/20140702091336/http://www.rastertek.com/dx11tut03.zip">dx11tut03.zip</A></FONT></P>
<P align=left><FONT color=#ffffff size=2 face=Arial>Source Only: <A 
href="http://web.archive.org/web/20140702091336/http://www.rastertek.com/dx11src03.zip">dx11src03.zip</A></FONT></P>
<P align=left><FONT color=#ffffff size=2 face=Arial>Executable Only: <A 
href="http://web.archive.org/web/20140702091336/http://www.rastertek.com/dx11exe03.zip">dx11exe03.zip</A></FONT></P>
<P align=left><IMG border=0 
src="Tutorial%203%20Initializing%20DirectX%2011_files/mhtC316(1).tmp" width=800 
height=1></P>
<P align=left><FONT color=#cccccc size=2 face="Arial, Helvetica, sans-serif"><A 
href="http://web.archive.org/web/20140702091336/http://www.rastertek.com/tutindex.html">Back 
to Tutorial Index</A></FONT></P><!--
     FILE ARCHIVED ON 9:13:36 Jul 2, 2014 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 12:16:18 Aug 7, 2014.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
--></BODY></HTML>
